#include <bits/stdc++.h>
#include <gtest/gtest.h>
#include <iostream>
#include <fstream>
#include <unordered_map>

#include "engine.hpp"
#include "globals.hpp"
#include "utility.hpp"

using namespace std;

typedef unordered_map<int, vector<string>> fen_map;

void recurse_moves_and_fill_fens(vector<string>& fen_holder, int depth, int max_depth, ShumiChess::Engine& engine) {
    if (depth > max_depth) {
        return;
    }
    vector<ShumiChess::Move> legal_moves = engine.get_legal_moves();
    for (ShumiChess::Move move : legal_moves) {
        engine.push(move);
        recurse_moves_and_fill_fens(fen_holder, depth + 1, max_depth, engine);
        if (depth == max_depth) {
            fen_holder.push_back(engine.game_board.to_fen());
        }
        engine.pop();
    }
}

vector<string> get_certain_depth_fens_from_engine(int depth) {
    vector<string> fen_holder;
    ShumiChess::Engine test_engine;
    recurse_moves_and_fill_fens(fen_holder, 1, depth, test_engine);
    return fen_holder;
}

int get_fens_by_depth_from_file(fen_map& fen_holder, string test_filename) {
    ifstream myfile(test_filename);
    if (!myfile.is_open()) {
        // TODO find better way to have this function fail
        cout << "ERROR: could not open file: " << test_filename << endl;
        assert(0 == 1);
    }
    
    cout << "running get_fens_by_depth_from_file" << endl;
    
    int depth = 0;
    string line;
    while (getline (myfile, line)) {
        if (utility::string::starts_with(line, "DEPTH")) {
            vector<string> splitted = utility::string::split(line, ":");
            depth = stoi(splitted.back());
            continue;
        }
        fen_holder[depth].push_back(line);
    }
    myfile.close();
    cout << "finished running get_fens_by_depth_from_file" << endl;
    return 0;
}

vector<int> get_keys_from_map(fen_map& map) {
    vector<int> keys;
    for (const auto& key_and_value : map) {
        keys.push_back(key_and_value.first);
    }
    sort(keys.begin(), keys.end());
    return keys;
}

string test_filename = "tests/test_data/legal_positions_by_depth.dat";
fen_map fens_by_depth;
int _ = get_fens_by_depth_from_file(fens_by_depth, test_filename);
vector<int> depths = get_keys_from_map(fens_by_depth);


class LegalPositionsByDepth : public testing::TestWithParam<int> {}; 
TEST_P(LegalPositionsByDepth, LegalPositionsByDepth) {
    int depth = GetParam(); 

    // construct baseline map from the known fens by depth
    unordered_map<string, int> baseline_fens;
    for (string i : fens_by_depth[depth]) {
        if (baseline_fens.find(i) == baseline_fens.end()) {
            baseline_fens[i] = 0;
        }
        baseline_fens[i]++;
    }

    // construct map based on ShumiChess engine
    vector<string> fen_data_engine = get_certain_depth_fens_from_engine(depth);
    unordered_map<string, int> shumi_fens;
    for (string i : fen_data_engine) {
        if (baseline_fens.find(i) == baseline_fens.end()) {
            shumi_fens[i] = 0;
        }
        shumi_fens[i]++;
    }

    // compare baseline and shumichess
    for (const auto& pair : baseline_fens) {
        string baseline_fen = pair.first;
        int baseline_times_appear = pair.second;
        
        if (shumi_fens.find(baseline_fen) == shumi_fens.end()) {
            ShumiChess::Engine test_engine1(baseline_fen);
            utility::representation::print_gameboard(test_engine1.game_board);
            cout << "Trying to find matching board positions (not perfect fen match)..." << endl;
            string just_position = utility::string::split(baseline_fen, " ")[0];
            for (const auto& pair2 : shumi_fens) {
                string fenner = pair2.first;
                int nothingmatters = pair2.second;
                string just_position2 = utility::string::split(fenner, " ")[0];
                if (just_position == just_position2) {
                    cout << "generated matching board found, fen is: " << fenner << ", board position is" << endl;
                    ShumiChess::Engine test_engine8(fenner);
                    utility::representation::print_gameboard(test_engine8.game_board);
                }
            }

            FAIL() << "At depth " << depth << " fen '" << baseline_fen <<
                "' was not found in positions generated by ShumiChess, bitboard rep of the missing fen above" << endl;
        }

        int shumi_times_appear = shumi_fens[baseline_fen];
        if (baseline_times_appear != shumi_times_appear) {
            ShumiChess::Engine test_engine2(baseline_fen);
            utility::representation::print_gameboard(test_engine2.game_board);
            FAIL() << "At depth " << depth << " fen '" << baseline_fen <<
                "' was found " << shumi_times_appear << " times in ShumiChess, and " << 
                baseline_times_appear << " in the baseline, bitboard rep above" <<  endl;
        }
    }

    for (const auto& pair : shumi_fens) {
        string shumi_fen = pair.first;
        int shumi_times_appear = pair.second;
        
        if (baseline_fens.find(shumi_fen) == shumi_fens.end()) {
            ShumiChess::Engine test_engine3(shumi_fen);
            utility::representation::print_gameboard(test_engine3.game_board);
            FAIL() << "At depth " << depth << " fen '" << shumi_fen <<
                "' was found in positions generated by ShumiChess but NOT by the baseline, bitboard rep above" << endl;
        }
    }
}
INSTANTIATE_TEST_CASE_P(LegalPositionsByDepthParam, LegalPositionsByDepth, testing::ValuesIn(depths));



// using qperft to determine number of legal moves by depth
// https://home.hccnet.nl/h.g.muller/dwnldpage.html
// perft( 1)=           20
// perft( 2)=          400
// perft( 3)=         8902
// perft( 4)=       197281
// perft( 5)=      4865609
// perft( 6)=    119060324

class NumberOfLegalPositionsByDepth : public testing::TestWithParam<int> {}; 
TEST_P(NumberOfLegalPositionsByDepth, NumberOfLegalPositionsByDepth) {
    int depth = GetParam(); 
    vector<string> fen_data_baseline = get_certain_depth_fens_from_engine(depth);
    int correct = 0; 
    if (depth == 1) {
        correct = 20;
    }
    else if (depth == 2) {
        correct = 400;
    }
    else if (depth == 3) {
        correct = 8902;
    }
    else if (depth == 4) {
        correct = 197281;
    }
    else if (depth == 5) {
        correct = 4865609;
    }
    ASSERT_EQ(correct, fen_data_baseline.size());
}
INSTANTIATE_TEST_CASE_P(NumberOfLegalPositionsByDepthParam, NumberOfLegalPositionsByDepth, testing::ValuesIn(depths));