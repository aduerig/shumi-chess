#include <bits/stdc++.h>
#include <gtest/gtest.h>
#include <iostream>
#include <fstream>
#include <unordered_map>

#include "engine.hpp"
#include "utility.hpp"
#include "globals.hpp"

using namespace std;

typedef unordered_map<int, vector<string>> fen_map;

void recurse_moves_and_fill_fens(fen_map& fen_holder, int depth, int max_depth, ShumiChess::Engine& engine) {
    if (depth > max_depth) {
        return;
    }

    vector<ShumiChess::Move> legal_moves = engine.get_legal_moves();
    for (ShumiChess::Move move : legal_moves) {
        engine.push(move);
        // if (depth == 3) {
        //     cout << "REP BELOW, FEN IS: " << engine.game_board.to_fen() << endl;
        //     utility::representation::print_gameboard(engine.game_board);
        //     cout << "=========" << endl;
        // }
        recurse_moves_and_fill_fens(fen_holder, depth + 1, max_depth, engine);
        fen_holder[depth].push_back(engine.game_board.to_fen());
        // if (engine.game_board.to_fen() == "rnbqkbnr/1ppppppp/8/p7/8/N7/PPPPPPPP/R1BQ1BNR b kq - 1 2") {
        //     cout << "after making move, move from: " << endl;
        //     utility::representation::print_bitboard(move.from);
        //     cout << "move to: " << endl;
        //     utility::representation::print_bitboard(move.to);

        //     utility::representation::print_gameboard(engine.game_board);
        //     engine.pop();
        //     cout << "after" << endl;
        //     utility::representation::print_gameboard(engine.game_board);
        // }
        engine.pop();
    }
}

fen_map get_fens_by_depth_from_engine(int depth) {
    fen_map fen_holder;
    ShumiChess::Engine test_engine;
    
    recurse_moves_and_fill_fens(fen_holder, 1, depth, test_engine);

    return fen_holder;
}

fen_map get_fens_by_depth_from_file(string test_filename) {
    fen_map fen_holder;
    ifstream myfile(test_filename);
    if (!myfile.is_open()) {
        // TODO find better way to have this function fail
        assert(0 == 1);
    }
    
    int depth = 0;
    string line;
    while (getline (myfile, line)) {
        if (utility::string::starts_with(line, "DEPTH")) {
            vector<string> splitted = utility::string::split(line, ":");
            depth = stoi(splitted.back());
            continue;
        }
        fen_holder[depth].push_back(line);
    }
    myfile.close();
    return fen_holder;
}

vector<int> get_keys_from_map(fen_map map) {
    vector<int> keys;
    for (const auto& key_and_value : map) {
        keys.push_back(key_and_value.first);
    }
    sort(keys.begin(), keys.end());
    return keys;
}

string test_filename = "tests/test_data/legal_positions_by_depth.dat";
fen_map fens_by_depth = get_fens_by_depth_from_file(test_filename);
vector<int> depths = get_keys_from_map(fens_by_depth);


class LegalPositionsByDepth : public testing::TestWithParam<int> {}; 
TEST_P(LegalPositionsByDepth, LegalPositionsByDepth) {
    int depth = GetParam(); 

    // construct baseline map from the known fens by depth
    vector<string> fen_data_baseline = get_fens_by_depth_from_file(test_filename)[depth];
    unordered_map<string, int> baseline_fens;
    for (string i : fen_data_baseline) {
        if (baseline_fens.find(i) == baseline_fens.end()) {
            baseline_fens[i] = 0;
        }
        baseline_fens[i]++;
    }

    // construct map based on ShumiChess engine
    vector<string> fen_data_engine = get_fens_by_depth_from_engine(depth)[depth];
    unordered_map<string, int> shumi_fens;
    for (string i : fen_data_engine) {
        if (baseline_fens.find(i) == baseline_fens.end()) {
            shumi_fens[i] = 0;
        }
        shumi_fens[i]++;
    } 

    // compare baseline and shumichess
    for (const auto& pair : baseline_fens) {
        string baseline_fen = pair.first;
        int baseline_times_appear = pair.second;
        
        if (shumi_fens.find(baseline_fen) == shumi_fens.end()) {
            cout << "somehow didnt find fen: " << baseline_fen << ", looping" << endl;
            // cout << "finding... " << shumi_fens.find("rnbqkbnr/p1pppppp/8/1p6/P7/8/RPPPPPPP/1NBQKBNR b KQkq - 1 2")->first << ", " << shumi_fens.find("rnbqkbnr/p1pppppp/8/1p6/P7/8/RPPPPPPP/1NBQKBNR b KQkq - 1 2")->second << endl;
            // for (const auto& pair2 : shumi_fens) {
            //     string fenner = pair2.first;
            //     int nothingmatters = pair2.second;
            //     cout << "fen 1: " << baseline_fen << "\nfen 2: " << fenner << "\nequality: " << (baseline_fen == fenner) << endl;
            // }
            ShumiChess::Engine test_engine1(baseline_fen);
            utility::representation::print_gameboard(test_engine1.game_board);
            FAIL() << "At depth " << depth << " fen '" << baseline_fen <<
                "' was not found in positions generated by ShumiChess, bitboard rep of the missing fen above" << endl;
        }

        int shumi_times_appear = shumi_fens[baseline_fen];
        if (baseline_times_appear != shumi_times_appear) {
            ShumiChess::Engine test_engine2(baseline_fen);
            utility::representation::print_gameboard(test_engine2.game_board);
            FAIL() << "At depth " << depth << " fen '" << baseline_fen <<
                "' was found " << shumi_times_appear << " times in ShumiChess, and " << 
                baseline_times_appear << " in the baseline, bitboard rep above" <<  endl;
        }
    }

    for (const auto& pair : shumi_fens) {
        string shumi_fen = pair.first;
        int shumi_times_appear = pair.second;
        
        if (baseline_fens.find(shumi_fen) == shumi_fens.end()) {
            ShumiChess::Engine test_engine3(shumi_fen);
            utility::representation::print_gameboard(test_engine3.game_board);
            FAIL() << "At depth " << depth << " fen '" << shumi_fen <<
                "' was found in positions generated by ShumiChess but NOT by the baseline, bitboard rep above" << endl;
        }
    }
}
INSTANTIATE_TEST_CASE_P(LegalPositionsByDepthParam, LegalPositionsByDepth, testing::ValuesIn(depths));



// using qperft to determine number of legal moves by depth
// https://home.hccnet.nl/h.g.muller/dwnldpage.html
// perft( 1)=           20
// perft( 2)=          400
// perft( 3)=         8902
// perft( 4)=       197281
// perft( 5)=      4865609
// perft( 6)=    119060324

class NumberOfLegalPositionsByDepth : public testing::TestWithParam<int> {}; 
TEST_P(NumberOfLegalPositionsByDepth, NumberOfLegalPositionsByDepth) {
    int depth = GetParam(); 
    int correct = 0; 
    if (depth == 1) {
        correct = 20;
    }
    else if (depth == 2) {
        correct = 400;
    }
    else if (depth == 3) {
        correct = 8902;
    }
    else if (depth == 4) {
        correct = 197281;
    }
    else if (depth == 5) {
        correct = 4865609;
    }
    vector<string> fen_data_baseline = get_fens_by_depth_from_file(test_filename)[depth];
    ASSERT_EQ(correct, fen_data_baseline.size());
}
INSTANTIATE_TEST_CASE_P(NumberOfLegalPositionsByDepthParam, NumberOfLegalPositionsByDepth, testing::ValuesIn(depths));